
![](img\2021-09-14-20-00-33.png)

当你读取一条记录时，SQL Server默认请求一个共享锁（S），当你修改一条记录时，SQL Server请求一个排它锁（X）。这2个锁彼此不兼容，当你同时向读写一条记录时，会发生阻塞。

另外对于行级别的锁，在锁层级里，SQL Server也会在更高一层请求所谓的意向锁（Intent Locks）：在页和表层级。SQL Server基于请求的行级别锁，请求下列的意向锁：

意向共享锁（Intent Shared Lock (IS)），当你在行层级有一个共享锁（S）
意向更新锁（Intent Update Lock (IU)），当你在行层级有一个更新锁（U）
意向排它锁（Intent Exclusive Lock (IX)），当你在行层级有一个排它锁（X）
因此当读或写你记录时，你总会获得如上图所示的锁层级。当SQL Server为什么使用这些意向锁呢？

SQL Server里的意向锁
从技术上来说，SQL Server并不真的需要意向锁。这和性能优化有关。我们来具体看下。有了意向锁，SQL Server表明在锁层级里更高层级上，你需要请求其他锁。意向共享锁（Intent Shared Lock）告诉SQL Server某个地方有共享锁（S）。对于意向更新锁（Intent Update Lock）或意向排它锁（Intent Exclusive Lock）也是一样，但这次SQL Server知道在某个地方有更新锁（Update Lock）或排它锁（Exclusive Lock）。这只是个标识，没别的。

但这个标识怎么帮助SQL Server性能优化？假设你再表层级请求一个排它锁（X）。在这个情况下，SQL Server需要知道在某个记录上是否有不兼容的锁（像共享锁（S）或更新锁（U））。没有意向锁，SQL Server需要检查每条记录来看是否有一个授予的不兼容锁。

但在表层级有意向共享锁（IS）的话，SQL Server马上知道在某个地方有授予的共享锁（S），因此在表层级不能请求排它锁（X）。这个就是SQL Server里存在意向锁的原因：在锁层级里，如果某个地方有不兼容的锁存在，可以让SQL Server快速查到。很简单，是不是？



# mainロック モード

- 共有 (S)
- 更新 (U)
- 排他 (X)

## 共有ロック

共有 (S) ロックを設定すると、同時に実行されている複数のトランザクションがペシミスティック同時実行制御の下でリソースの読み取り (SELECT) を行います。詳細については、「同時実行制御の種類」を参照してください。他のトランザクションは、リソースに共有 (S) ロックがかけられている間はデータを変更できません。共有 (S) ロックは、読み取りが完了するとすぐに解除されます。ただし、トランザクションの分離レベルが REPEATABLE READ 以上に設定されている場合や、トランザクションの間、ロック ヒントを使用して共有 (S) ロックを保つ場合を除きます。

## 更新ロック
更新 (U) ロックは、一般的な形式のデッドロックを防ぎます。REPEATABLE READ または SERIALIZABLE のトランザクションは、データを読み取るときにリソース (ページまたは行) に共有 (S) ロックをかけます。その後、行を変更しますが、そのときにロックを排他 (X) ロックに変換する必要があります。2 つのトランザクションが 1 つのリソースに対して共有ロックをかけデータを同時に更新する場合、一方のトランザクションは排他 (X) ロックへの変換を試みます。一方のトランザクションの排他ロックは、もう一方のトランザクションの共有ロックとは両立しないので、共有ロックから排他ロックへの変換が待機状態になります。つまり、ロック待機となります。もう一方のトランザクションも更新のために排他 (X) ロックの取得を試みます。この場合、2 つのトランザクションが排他 (X) ロックへの変換を行っており、相手方のトランザクションが共有ロックを解除するのを待っている状態なので、デッドロックが発生します。

このような潜在的なデッドロックの問題を解決するには、更新 (U) ロックを使用します。更新 (U) ロックでは、1 つのリソースを一度にロックできるトランザクションは、1 つだけです。トランザクションがリソースを変更する場合に更新 (U) ロックが排他 (X) ロックに変換されます。


## 排他ロック
排他 (X) ロックは、同時に実行されている複数のトランザクションが同じリソースにアクセスすることを防ぎます。排他 (X) ロックをかけた以外のトランザクションはデータを変更できませんが、NOLOCK ヒントまたは READ UNCOMMITTED 分離レベルが指定されている場合に限り、読み取り操作は行うことができます。

INSERT、UPDATE、DELETE などのデータ変更ステートメントの中では、変更操作と読み取り操作が組み合わせて使用されます。最初に読み取り操作でデータを取得してから、必要な変更操作を実行します。したがって、一般的にデータ変更ステートメントには共有ロックおよび排他ロックの両方が必要です。たとえば、UPDATE ステートメントによって、他のテーブルとの結合を基にテーブルの行を変更するとします。このとき、結合テーブルの読み取る行に対する共有ロックと、更新する行に対する排他ロックが要求されます。

# ロックの保持期間

## 明示的なトランザクション(begin tran - commit tran)を使わない場合
クエリ実行直後にロックを開放。

## 明示的なトランザクションを使う場合

- Sロック: 
  クエリ実行直後にロックを開放。（既定のトランザクション分離レベルである「Read Committed」の場合の挙動）
- Uロック / Xロック：
  クエリの開始からトランザクションのコミット又はロールバックが完了するまでロックを保持する。

# 例 WITH(NOWAIT,ROWLOCK,UPDLOCK);

SELECT * FROM TEST1  WITH(NOWAIT,ROWLOCK,UPDLOCK)
where state = 1；

就是用UPDLOCK,只用ROWLOCK
我个人觉得可以不指定ROWLOCK，交由系统自己判断使用ROWLOCK，还是PAGELOCK

## NOWAIT
如果锁被占用，不用等直接返回报错

## ROWLOCK
使用行级锁，而不使用粒度更粗的页级锁和表级锁。
ROWLOCK语法可以使用在SELECT,  UPDATE和DELETE语句中，会和UPDLOCK一起使用

## UPDLOCK
读取表时使用更新锁，而不使用共享锁，并将锁一直保留到语句或事务的结束。UPDLOCK 的优点是允许您读取数据（不阻塞其它事务）并在以后更新数据，同时确保自从上次读取数据后数据没有被更改。
可以是ROWLOCK，也可以是PAGELOCK

在update语句加行级更新锁，实际上更新语句本身默认更新锁，下面两个语句是一样的
update User with (updlock,rowlock)  set f_money = f_money + 100 where f_name = '张三'
 update User   with (rowlock)     set f_money = f_money + 100   where f_name = '张三'

## XLOCK 
使用排它锁并一直保持到由语句处理的所有数据上的事务结束时。可以使用 PAGLOCK 或 TABLOCK 指定该锁，这种情况下排它锁适用于适当级别的粒度。 

# 参照url

https://qiita.com/maaaaaaaa/items/38fd95b142b07acf7700

https://docs.microsoft.com/ja-jp/previous-versions/sql/sql-server-2008-r2/ms175519%28v%3dsql.105%29

https://raw.githubusercontent.com/MasayukiOzawa/SQLServer-Util/master/Lock/%E3%83%96%E3%83%AD%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E3%81%AE%E5%8F%96%E5%BE%97.sql