# 概述

SwiftUI与苹果之前的UI框架的区别不仅仅在于如何定义视图和其他UI组件，还在于如何在整个使用它的应用程序中管理视图层级的状态。

SwiftUI没有使用委托、数据源或任何其他在UIKit和AppKit等命令式框架中常见的状态管理模式，而是配备了一些属性包装器，使我们能够准确地声明我们的数据如何被我们的视图观察、渲染和改变。











SwiftUI的状态管理是通过设置数据是有状态的然后绑定数据实现的

通过在属性showFavoritesOnly前加@State修饰符来表明这个数据是有状态的

Toggle是那个Switch按钮它的值通过$符绑定在了showFavoritesOnly属性上，当点击按钮值变化时body会自动再次执行

```swift
struct LandmarkList: View {    
    @State var showFavoritesOnly = true    
    var body: some View {        
        NavigationView {            
            List {                
                Toggle(isOn: $showFavoritesOnly) { 
                    Text("Favorites only")
                }                
                ForEach(landmarkData) { 
          			landmark in
                    if !self.showFavoritesOnly || landmark.isFavorite {    
                        NavigationLink(destination: LandmarkDetail(landmark: landmark)) { 
                            LandmarkRow(landmark: landmark)                        
                        }
                    }
                }
            }
            .navigationBarTitle(Text("Landmarks"))
        }
    }}

```



## 数据流管理

SwiftUI 是一个典型的单向数据流得声明式 UI 编程框架, 在 SwiftUI 中 View 只是一个页面的描述部分，SwiftUI 提供了多个数据流管理对象。`@State` `@Binding` `@Obserabled` ,通过改变这些数据流的值，SwiftUI 系统可以理解重新构建 View Tree。

### State

State 是 SwiftUI 中最常用的 代理属性，通过对代理属性的修改，SwiftUI 内部会自动的重新计算 View 的 Body 部分，构建 出 View Tree。注意 **State 只能在当前 View 的 body 体里面修改**，所以 State 的适用场景就是只影响当前 View 内部的变化的操作。

举个实际的例子就是类似下载网络图片的部分，调用方通常提供一个 URL 和 Placeholder Image，在 SwiftUI 中使用 State 即可，因为此时的网络图变化只影响当前 View。

```swift

struct NetworkImage: SwiftUI.View {
    
    var urlPath: String?
    var placeHodlerImage: UIImage
    
    init(url path: String?, placeHolder: String) {
        self.urlPath = path
        self.placeHodlerImage = UIImage(named: placeHolder)!.withRenderingMode(.alwaysOriginal)
    }

    @State var downLoadedImage: UIImage? = nil
    
    var body: some SwiftUI.View {
        Image(uiImage: downLoadedImage ?? placeHodlerImage)
                          .resizable()
                          .aspectRatio(contentMode: .fill)
                          .onAppear(perform: download)
    }
    
    func download() {
        if let _ = downLoadedImage {
        	return
        }
    	_ = urlPath.flatMap(URL.init(string:)).map {
            ImageDownloader.default.downloadImage(with: $0) { 
                result in
                    switch result {
                        case .success(let value):
                            self.downLoadedImage = value.image.withRenderingMode(.alwaysOriginal)
                        case .failure(let error):
                             log.debug(error)

                    }
                }
            }
        }
}

```



### Binding

SwiftUI 给我们的理念就是 Single source of truth, 简单来说就是单一数据源

SwiftUI 给我们的解决办法就是 `@Binding` 。

```swift

struct DateVersionPanel : View {
    
@Binding var version: String
@State var input = ""
@Binding var date: Date
var title: String
    
@State private var showVersionPicker = false
@State private var showDatePicker = false
    
var dateFormatter: DateFormatter {
let formatter = DateFormatter()
    formatter.dateFormat = "yyyy-MM-dd"
    return formatter
}
private func showDate() {
    showDatePicker = true
}
    
var body: some View {
        HStack(alignment: .center) {
            Text(title)
                .font(.system(size: 14))
            
            HStack(alignment: .center) {

                TextField(version.isEmpty ? "不区分版本" : version, text: $input, onEditingChanged: { (changed) in
                    log.debug("TextFieldonEditing: \(changed)")
                }) {
                    log.debug("TextFielduserName: \(self.version)")
                    self.version = self.input
                }
                .font(.system(size: 9))
                .padding(.leading, 20)
                .frame(width: 100, height: 20)
                
                NavigationLink(destination: VersionSelectView(version: $version)) {
                    Image("down_arrow")
                        .frame(width: 24, height: 14)
                        .aspectRatio(contentMode: .fill)
                }
                .offset(x: -20)
                
            }
            .frame(width: 100, height: 25)
            .border(Color.grayText, width: 0.5)
            .padding(.leading, 40)
            
            
            NavigationLink(destination: CalendarView(date: self.$date)) {
                
                
                HStack {
                    Text(dateFormatter.string(from: date) )
                        .font(.system(size: 9))
                        .padding(.leading, 10)
                    Image("down_arrow").padding(.trailing, 10)
                }
                .frame(width: 100, height: 25)
                .border(Color.grayText, width: 0.5)
                .padding(.leading, 40)
            }
            
        }
        .padding(.bottom, 10)
        
    }
}

```



### ObservableObject



### Redux

Redux 的基本思想核步骤是：

- 整个页面甚至 APP 是一个巨大的状态机，有一个状态存储 Store ，在某个时刻处于某种状态。
- 状态在页面表达中是一个简单的树型结构，在 SwiftUI，对应的 就是 View Tree。
- View 操作不能直接修改状态，只能通过发送 Action, 间接改变 Store。
- Reducer 通过 Action 加上 oldState 获取 newSatete。简单来说就是 State = f(action+oldState)。