iOS 14为我们提供了三个用于数据持久性的新属性包装器：

- `@AppStorage`

- `@StateObject`

- `@SceneStorage`

  # SwiftUI @AppStorage **(**SwiftUI @AppStorage**)**

  `AppStorage`属性包装器用于读取和写入值到`UserDefaults` 。 每次`AppStorage`属性包装器的值更改时，SwiftUI视图都会无效并重新绘制。

  它的行为与`@State`属性包装器相同，不同之处在于，它用于以方便的方式在`UserDefaults`键和SwiftUI视图之间进行通信。 以下代码显示了我们如何在iOS 14之前使用`UserDefaults`和`State`属性包装器：

  新的`@AppStorage`属性包装器可以单行执行此操作：

  ```kotlin
  @AppStorage("name") var name: String = "hey"
  ```

  `AppStorage` ，您还可以使用不同的`suiteName`为`UserDefaults`而不是默认的`standard` 。

  另外，我们还可以使用`wrappedValue`参数直接在`@AppStorage`内部设置`UserDefaults`键的默认值。

  这是上述每种情况的语法：

  

  在`TextField`使用`AppStorage`似乎很有吸引力-尤其是因为存储和更新登录凭据是一种常见的用例。 但是这样做时，您的`UserDefaults`将在用户每次在TextField中输入或删除某些内容时进行更新，这可能并不理想。

  .

  在基于计数器的应用程序中使用`@AppStorage`一种更好的方案是在应用程序会话中保留值。 甚至可以在新的SwiftUI `TextEditor`中构建方便的记事本应用程序。

  ```swift
  @AppStorage("text") var text: String = ""var body: some View {        Text($text)}
  ```

  # SwiftUI @StateObject **(**SwiftUI @StateObject**)**

  引入了`StateObjects`来填补`@EnvironmentObject`和`@ObservedObject`之间的空白。

  虽然`EnvironmentObject`属性包装器用作共享数据，该共享数据可在应用程序中的所有SwiftUI视图中使用，但是`ObservedObject`通常用于插入符合`ObservableObject`协议的数据源类。

  在一个SwiftUI中设置的`@ObservedObject`也可以与其他视图共享，这可能会无意中导致棘手的问题。 例如，如果您尝试更新已初始化`ObservedObject`的SwiftUI视图(也许通过更改状态)，则会重新创建模型：

  ```kotlin
  @ObservedObject var model = MyViewModel()
  ```

  尽管您可以摆脱上面的`MyViewModel()`默认值，并在`init`中将模型作为参数传递，但是当您与其他子视图共享`ObservedObject`时，您将失去确定真相来源的能力。

  iOS 14中的`@StateObject`带来了一个新的`@StateObject`属性包装器，该包装器不会在状态更改时重新初始化。

  所以现在，您可以像这样用`@StateObject`来愉快地替换`@ObservedObject` ：

  ```kotlin
  @StateObject var model = MyViewModel
  ```

  # SwiftUI @SceneStorage **(**SwiftUI @SceneStorage**)**

  新的`SceneStorage`属性在具有多窗口支持的应用程序(通常基于iPadOS和macOS构建)的状态恢复中非常方便。

  与`AppStorage`不同，它不会在`UserDefaults`保存数据。 相反，它只是状态属性，对于您的应用程序中的每个场景都是唯一的。

  ```kotlin
  @SceneStorage("isLoggedIn") var isLoggedIn = false
  ```