# 强引用、软引用、弱引用和虚引用

从 JDK1.2 版本开始，Java 把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。

## 1.强引用（Strong Reference）

- ### 概念

  强引用就是我们经常使用的引用，其写法如下：

  ```java
  Object o = new Object();
  ```

  

- ### 特点

  **垃圾回收器绝不会回收它**。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

- ### 使用场景

  大多数平常就是强引用

- ### 例子

  只要还有强引用指向一个对象，垃圾收集器就不会回收这个对象；显式地设置 o 为 null，或者超出对象的生命周期，此时就可以回收这个对象。具体回收时机还是要看垃圾收集策略。

  在不用对象的时将引用赋值为 null，能够帮助垃圾回收器回收对象。比如  ArrayList 的 clear() 方法实现：

  ```java
   public void clear() {
       modCount++;
  
       // clear to let GC do its work
       for (int i = 0; i < size; i++)
           elementData[i] = null;
       size = 0;
   }
  ```



## 2.软引用（SoftReference）

- ### 概念

  其写法如下：

  ```java
  Object o = new Object();
  SoftReference sr = new SoftReference(o); 
  ```

  

- ### 特点

  **内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存**

- ### 使用场景

  软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

  图片缓存。图片缓存框架中，“内存缓存”中的图片是以这种引用保存，使得  JVM 在发生 OOM 之前，可以回收这部分缓存。此外，还可以用在网页缓存上。

- ### 例子

  注意一定要判断软引用的对象是否为null。

  ```java
  Browser prev = new Browser();               // 获取页面进行浏览
  SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用        
  if(sr.get()!=null) { 
      rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取
  } else {
      prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了
      sr = new SoftReference(prev);       // 重新构建
  }
  ```

## 3.弱引用（Weak Reference）

- ### 概念

  简单来说，就是将对象留在内存的能力不是那么强的引用。当垃圾回收器扫描到只具有弱引用的对象，不管当前内存空间是否足够，都会回收内存。，其写法如下：

  ```java
  Object o = new Object();
  WeakReference<A>  = new WeakReference<>(a);
  ```

  

- ### 特点

  gc执行**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**

- ### 使用场景

  **弱引用的作用**在于解决强引用所带来的对象之间在存活时间上的耦合关系。弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何Java对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存。

  **WeakHashMap**
  为了更方便使用弱引用，Java还提供了WeakHashMap，功能类似HashMap，内部实现是用弱引用对key进行包装，当某个key对象没有任何强引用指向，gc会自动回收key和value对象。

  **解决内存泄漏**。（Android的 Activity 和 Handle）

  如果类 B 不是虚引用类 A 的话，执行 main 方法会出现内存泄漏的问题， 因为类 B 依然依赖于 A。

  在静态内部类中，经常会使用虚引用。例如：一个类（外部类）发送网络请求，承担 callback 的静态内部类，则常以虚引用的方式来保存外部类的引用，当外部类需要被 JVM 回收时，不会因为网络请求没有及时回应，引起内存泄漏。

  

- ### 例子

  在Java中，非静态内部类 & 匿名内部类都默认持有 外部类的引用

  **内存泄漏**

  下述的Handler实例的消息队列有2个分别来自线程1、2的消息（分别 为延迟1s、6s） 在Handler消息队列 还有未处理的消息 / 正在处理消息时，消息队列中的Message持有Handler实例的引用 由于Handler = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即MainActivity实例），上述的引用关系会一直保持，直到Handler消息队列中的所有消息被处理完毕 在Handler消息队列 还有未处理的消息 / 正在处理消息时，此时用户切换MainActivity到Activity1需销毁外部类MainActivity，但由于上述引用关系，垃圾回收器（GC）无法回收MainActivity，从而造成内存泄漏。

  ```java
    public class MainActivity extends AppCompatActivity {
          public static final String TAG = "carson：";
          private Handler showhandler;
  
          // 主线程创建时便自动创建Looper & 对应的MessageQueue
          // 之后执行Loop()进入消息循环
          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);
  
              //1. 通过匿名内部类实例化的Handler类对象
              //注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue
              showhandler = new  Handler(){
                  // 通过复写handlerMessage()从而确定更新UI的操作
                  @Override
                  public void handleMessage(Message msg) {
                          switch (msg.what) {
                              case 1:
                                  Log.d(TAG, "收到线程1的消息");
                                  // 更新UI
                                  break;
                              case 2:
                                  Log.d(TAG, " 收到线程2的消息");
                                  // 更新UI
                                  break;
                          }
                      }
              };
  
              // 2. 启动子线程1执行耗时任务
              new Thread() {
                  @Override
                  public void run() {
                      try {
                          // 执行耗时任务
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      // 任务完成时向UI主线程发送消息通知调用CallBack（handleMessage）函数更新UI
                      // a. 定义要发送的消息
                      Message msg = Message.obtain();
                      msg.what = 1;// 消息标识
                      msg.obj = "AA";// 消息存放
                      // b. 向主线程的Handler & 向其MessageQueue发送消息
                      showhandler.sendMessage(msg);
                  }
              }.start();
  
              // 3. 启动子线程2执行耗时任务
              new Thread() {
                  @Override
                  public void run() {
                      try {
                          // 执行耗时任务
                          Thread.sleep(5000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      // a. 定义要发送的消息
                      Message msg = Message.obtain();
                      msg.what = 2;// 消息标识
                      msg.obj = "BB";// 消息存放
                      // b. 传入主线程的Handler & 向其MessageQueue发送消息
                      showhandler.sendMessage(msg);
                  }
              }.start();
  
          }
  }
  ```

  

  **静态类 + 弱引用**

  定义静态内部类 private static class FHandler extends Handler

  并且弱引用MainActivity的实例 private WeakReference<Activity> reference 

  用户切换MainActivity到Activity1需销毁外部类MainActivity，由于为弱引用，垃圾回收器（GC）回收MainActivity，不会造成内存泄漏。但是更新UI之前一定要判断是否 reference.get()为null。

  

  ```java
  public class MainActivity extends AppCompatActivity {
  
      public static final String TAG = "carson：";
      private Handler showhandler;
  
      // 主线程创建时便自动创建Looper & 对应的MessageQueue
      // 之后执行Loop()进入消息循环
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
  
          //1. 实例化自定义的Handler类对象->>分析1
          //注：
              // a. 此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue；
              // b. 定义时需传入持有的Activity实例（弱引用）
          showhandler = new FHandler(this);
  
          // 2. 启动子线程1
          new Thread() {
              @Override
              public void run() {
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  // a. 定义要发送的消息
                  Message msg = Message.obtain();
                  msg.what = 1;// 消息标识
                  msg.obj = "AA";// 消息存放
                  // b. 传入主线程的Handler & 向其MessageQueue发送消息
                  showhandler.sendMessage(msg);
              }
          }.start();
  
          // 3. 启动子线程2
          new Thread() {
              @Override
              public void run() {
                  try {
                      Thread.sleep(5000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  // a. 定义要发送的消息
                  Message msg = Message.obtain();
                  msg.what = 2;// 消息标识
                  msg.obj = "BB";// 消息存放
                  // b. 传入主线程的Handler & 向其MessageQueue发送消息
                  showhandler.sendMessage(msg);
              }
          }.start();
  
      }
  
      // 分析1：自定义Handler子类
      // 设置为：静态内部类
      private static class FHandler extends Handler{
  
          // 定义 弱引用实例
          private WeakReference<Activity> reference;
  
          // 在构造方法中传入需持有的Activity实例
          public FHandler(Activity activity) {
              // 使用WeakReference弱引用持有Activity实例
              reference = new WeakReference<Activity>(activity); }
  
          // 通过复写handlerMessage() 从而确定更新UI的操作
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  case 1:
                      Log.d(TAG, "收到线程1的消息");
                       // 更新UI
                      break;
                  case 2:
                      Log.d(TAG, " 收到线程2的消息");
                       // 更新UI
                      break;
  
  
              }
          }
      }
  }
  ```

  



## 4.虚引用（Phantom Reference）

- ### 概念

  虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

  ```java
  Object obj = new Object();
  ReferenceQueue refQueue = new ReferenceQueue();
  PhantomReference<Object> phantomReference = new PhantomReference<Object>(obj,refQueue);
  ```

  

- ### 特点

  当垃圾回收器回收一个对象时，如果**发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列**中。

- ### 使用场景

  由于Object.finalize()方法的不安全性、低效性，不可靠，常常使用虚引用完成对象回收前的资源释放工作

  可以用来跟踪对象垃圾回收的活动。一般可以通过虚引用达到回收一些非java内的一些资源比如堆外内存的行为。

- ### 例子

  例如：在 DirectByteBuffer 中，会创建一个 PhantomReference 的子类Cleaner的虚引用实例用来引用该 DirectByteBuffer 实例，Cleaner 创建时会添加一个 Runnable 实例，当被引用的 DirectByteBuffer 对象不可达被垃圾回收时，将会执行 Cleaner 实例内部的 Runnable 实例的 run 方法，用来回收堆外资源。









